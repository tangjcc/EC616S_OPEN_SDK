/*******************************************************************************(C) Copyright 2020 EIGENCOMM International Ltd.* All Rights Reserved*******************************************************************************  Filename:**  Description: esim AT commands interface function**  History:     09/22/2020  yjwang create*  Notes:    NULL*******************************************************************************/#ifdef SOFTSIM_CT_ENABLE#include <stdlib.h>#include <string.h>#include "atc_decoder.h"#include "at_util.h"#include "cmicomm.h"#include "cms_comm.h"#include "cmisim.h"#include "cms_util.h"#include "debug_trace.h"#include "debug_log.h"#include "bsp.h"#include "atec_cust_softsim.h"#include "esimmonitortask.h"extern osMessageQueueId_t esimInQHandle;osMessageQueueId_t        at_recv_msgqueue = NULL;static  UINT8             bFirstInit =  FALSE;static  UINT32            bEnableEchoFlag =  FALSE;extern  UINT32 mwGetAtChanConfigItemValue(UINT8 chanId, MidWareATChanCfgEnum cfgEnum);extern  void   mwSetAndSaveAtChanConfigItemValue(UINT8 chanId, MidWareATChanCfgEnum cfgEnum, UINT32 value);/**   \fn          esimProcessRespMsg   \brief       handle the SIG_ESIM_SIGNAL_SEND_CNF from esimproctask   \param[in]   indHandle:                AT handle;     pHexData   SIG_ESIM_SIGNAL_SEND_CNF SIG data    \returns     CmsRetId*/CmsRetId  esimProcessRespMsg(UINT16 indHandle,void *pHexData){    CmsRetId      ret = CMS_FAIL;    CHAR          *pHexStrRspMsg = NULL;    eSimCmsAtDataCnfMsg    *pcmsAtResp    = (eSimCmsAtDataCnfMsg*)pHexData;    eSimProcTaskMsg        *peSimSendMsg  = eSimTaskGetInstance();    if(pcmsAtResp->errcode != ESIM_RET_RESULT_OK)    {        if(pcmsAtResp->respData)        {            free(pcmsAtResp->respData);            pcmsAtResp->respData = NULL;        }        ret = atcReply((UINT32)pcmsAtResp->respHandle, AT_RC_ERROR, 50, NULL);        return ret;    }    pHexStrRspMsg  = (CHAR *)malloc(pcmsAtResp->respLen * 2 + 1);    if(pHexStrRspMsg == NULL)    {         ECOMM_TRACE(UNILOG_ATCMD_EXEC, esimProcessRespMsg_2, P_WARNING, 0,"pHexStrRspMsg FAIL!!!!");         ret = atcReply((UINT32)pcmsAtResp->respHandle, AT_RC_ERROR, 50, NULL);         return ret;    }    memset(pHexStrRspMsg,0x0,(pcmsAtResp->respLen * 2 + 1));    if(cmsHexToHexStr(pHexStrRspMsg, (pcmsAtResp->respLen * 2 + 1),                     (const UINT8*)pcmsAtResp->respData, pcmsAtResp->respLen) < 0)    {        ret = atcReply((UINT32)pcmsAtResp->respHandle, AT_RC_ERROR, 50, NULL);        return ret;    }    ret = atcReply(pcmsAtResp->respHandle, AT_RC_OK, 0,pHexStrRspMsg);    free(pHexStrRspMsg);    pHexStrRspMsg = NULL;    if(pcmsAtResp->respData)    {        free(pcmsAtResp->respData);        pcmsAtResp->respData = NULL;    }    //recevied this message means that should destory the esim task    if(pcmsAtResp->type == ESIM_OPERATE_ID_LOADBOUNDPROFILE_SERVICE)    {        mwSetAndSaveAtChanConfigItemValue(0, MID_WARE_AT_CHAN_ECHO_CFG, (UINT32)bEnableEchoFlag);        ret = eSimSendIndSigReq(esimInQHandle,indHandle,ESIM_MSG_IND_FINISHED);    }    return ret;}/**  \fn          eSimDynamicGetHexStrValue  \brief       dynamic malloc the buffer to store the HEX string and transfer it to HEX DATA  \param[in]   INT32          pVal,               AtParamValueCP pAtParaList,               UINT32         index,  \param[out]   pOutStr : the destnation HEX DATACLK_DATA                OutLen  : the destnation data LEN  \returns      AtParaRet*/static AtParaRet eSimDynamicGetHexStrValue(                        INT32          pVal,                        AtParamValueCP pAtParaList,                        UINT32         index,                        UINT8         **pOutStr,                        UINT16         *OutLen){    INT16    length    = 0;    UINT8   *pTemp     = NULL;    CHAR    *pStrBegin = NULL;    UINT16   HexLen    = 0;    UINT16   remain    = 0;    *pOutStr = NULL;    OsaDebugBegin(pAtParaList[index].value.pStr != PNULL, index, pAtParaList[index].value.pStr, 0);    return AT_PARA_ERR;    OsaDebugEnd();    pStrBegin =   (CHAR *)pAtParaList[index].value.pStr;    if(pVal == ESIM_OPERATE_ID_LOADBOUNDPROFILE_SERVICE)    {        pStrBegin += 4;    }    if(pStrBegin == NULL)    {        ECOMM_TRACE(UNILOG_ATCMD_EXEC, eSimDynamicGetHexStrValue_00, P_INFO,0 ,"pStrBegin is NULL!!!");        return AT_PARA_ERR;    }    length = strlen(pStrBegin);    HexLen =  length/2;    remain =  length%2;    HexLen += remain;    pTemp  =  malloc(HexLen);    if(!pTemp)    {       ECOMM_TRACE(UNILOG_ATCMD_EXEC, eSimDynamicGetHexStrValue_1, P_INFO,0 ,"pTemp fail!!!");       return AT_PARA_ERR;    }    memset(pTemp,0x0,HexLen);    if(cmsHexStrToHex(pTemp,(HexLen),pStrBegin,length) != (HexLen))    {         free(pTemp);         ECOMM_TRACE(UNILOG_ATCMD_EXEC, eSimDynamicGetHexStrValue_3, P_INFO, 1,"cmsHexStrToHex len:%d fail!!!",HexLen);         return AT_PARA_ERR;    }    *pOutStr = pTemp;    *OutLen  = HexLen;    return AT_PARA_OK;}/**  \fn          esimDATACONFIG  \brief       at+esim command handle API  \param[in]   const AtCmdInputContext *pAtCmdReq  \returns     CmsRetId*/CmsRetId esimDATACONFIG(const AtCmdInputContext *pAtCmdReq){    CmsRetId            ret         = CMS_FAIL;    UINT32              atHandle    = AT_SET_SRC_HANDLER(pAtCmdReq->tid, CMS_DEFAULT_SUB_AT_ID, pAtCmdReq->chanId);    UINT32              operaType   = (UINT32)pAtCmdReq->operaType;    AtParamValueCP      pParamList  = pAtCmdReq->pParamList;    INT32               parVal;    UINT8              *atSendBuf   = NULL;    UINT16              atSendLen   = 0;    eSimProcTaskMsg    *peSimSendMsg = eSimTaskGetInstance();    switch (operaType)    {        case AT_TEST_REQ:            /* AT+eSIM=? */        {            ret = atcReply(atHandle, AT_RC_OK, 0, (CHAR *)"+ESIM: (0,1,10,11,12,13,14)");            break;        }        case AT_READ_REQ:           /* AT+eSIM?  is not support*/        {            ret = atcReply(atHandle, AT_RC_CME_ERROR, CME_EAP_METHOD_NOT_SUPPORT, NULL);            break;        }        case AT_SET_REQ:            /*AT+eSIM=*/        {            if(0 == bFirstInit)            {                /*firstly resaved the former AT channel ECHO cfg value before setting it 0*/                bEnableEchoFlag = mwGetAtChanConfigItemValue((UINT8)pAtCmdReq->chanId, (MidWareATChanCfgEnum)ATC_CFG_ECHO_PARAM);                mwSetAndSaveAtChanConfigItemValue(pAtCmdReq->chanId, MID_WARE_AT_CHAN_ECHO_CFG, (UINT32)0);                eSimCreateProcTaskInQ();                eSimCreateProcTask();                eSimProcInit();                bFirstInit = 1;            }            OsaCheck(peSimSendMsg->init == 1, 0, 0, 0);            if(eSimProcGetWorkFlag() != ESIM_TASK_STATE_IDLE )            {                ret = atcReply(atHandle, AT_RC_CME_ERROR, CME_SYS_FAIL, NULL);                break;            }            if((atGetNumValue(pParamList, 0, &parVal, ATC_ESIM_0_FUN_VAL_MIN, ATC_ESIM_0_FUN_VAL_MAX, ATC_ESIM_0_FUN_VAL_DEFAULT)) != AT_PARA_ERR)            {                if(parVal == ESIM_OPERATE_ID_CSR_SERVICE          ||                   parVal == ESIM_OPERATE_ID_CERT_SERVICE         ||                   parVal == ESIM_OPERATE_ID_AUTHSERREQ_SERVICE   ||                   parVal == ESIM_OPERATE_ID_PREDOWNLOAD_SERVICE  ||                   parVal == ESIM_OPERATE_ID_LOADBOUNDPROFILE_SERVICE)                {                   if(eSimDynamicGetHexStrValue(parVal,pParamList, 1, &atSendBuf,&atSendLen) == AT_PARA_ERR)                   {                        ret = atcReply(atHandle, AT_RC_CME_ERROR, CME_INCORRECT_PARAM, NULL);                        ECOMM_TRACE(UNILOG_ATCMD_EXEC, esimDATACONFIG_1, P_INFO, 0,"eSimDynamicGetStrValue  ERROR");                        break;                   }                }                else if( parVal == ESIM_OPERATE_ID_UICC_SERVICE   ||                         parVal == ESIM_OPERATE_ID_CHALLENGE_SERVICE)                {                    atSendLen = 0;                    atSendBuf = NULL;                }                else if(parVal == ESIM_OPERATE_ID_VENDER_ID)                {                    CHAR       *pShowInfo   = NULL;                    #if defined CHIP_EC616 || defined CHIP_EC616_Z0                        pShowInfo = "EC616";                    #elif defined CHIP_EC616S                        pShowInfo = "EC617";                    #endif                    ret = atcReply(atHandle, AT_RC_OK, 0, pShowInfo);                    break;                }                else                {                    ret = atcReply(atHandle, AT_RC_CME_ERROR, CME_EAP_METHOD_NOT_SUPPORT, NULL);                    ECOMM_TRACE(UNILOG_ATCMD_EXEC, esimDATACONFIG_3, P_INFO, 0,"invalid CMD!");                    break;                }                if((ret = (eSimSendAtDataReq(atHandle,parVal,atSendBuf,atSendLen))) != CMS_RET_SUCC)                {                    ret = atcReply(atHandle, AT_RC_CME_ERROR, CME_SYS_FAIL, NULL);                    break;                }            }            break;        }        default:        {            ret = atcReply(atHandle, AT_RC_CME_ERROR, CME_INCORRECT_PARAM, NULL);            break;        }    }   return ret;}#endif
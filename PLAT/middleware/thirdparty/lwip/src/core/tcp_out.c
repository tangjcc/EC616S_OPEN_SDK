/**
 * @file
 * Transmission Control Protocol, outgoing traffic
 *
 * The output functions of TCP.
 *
 */

/*
 * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 * This file is part of the lwIP TCP/IP stack.
 *
 * Author: Adam Dunkels <adam@sics.se>
 *
 */

#include "lwip/opt.h"

#if LWIP_TCP /* don't build if not configured for use in lwipopts.h */

#include "lwip/priv/tcp_priv.h"
#include "lwip/def.h"
#include "lwip/mem.h"
#include "lwip/memp.h"
#include "lwip/ip_addr.h"
#include "lwip/netif.h"
#include "lwip/inet_chksum.h"
#include "lwip/stats.h"
#include "lwip/ip6.h"
#include "lwip/ip6_addr.h"
#if LWIP_TCP_TIMESTAMPS
#include "lwip/sys.h"
#endif

#include <string.h>

#if LWIP_TIMER_ON_DEMOND
#include "lwip/timeouts.h"
#endif

#if ENABLE_PSIF
#include "pscommtype.h"
#include "lwip/udp.h"
#endif

#if PS_ENABLE_TCPIP_HIB_SLEEP2_MODE
#include "psifhib.h"
#endif





/* Define some copy-macros for checksum-on-copy so that the code looks
   nicer by preventing too many ifdef's. */
#if TCP_CHECKSUM_ON_COPY
#define TCP_DATA_COPY(dst, src, len, seg) do { \
  tcp_seg_add_chksum(LWIP_CHKSUM_COPY(dst, src, len), \
                     len, &seg->chksum, &seg->chksum_swapped); \
  seg->flags |= TF_SEG_DATA_CHECKSUMMED; } while(0)
#define TCP_DATA_COPY2(dst, src, len, chksum, chksum_swapped)  \
  tcp_seg_add_chksum(LWIP_CHKSUM_COPY(dst, src, len), len, chksum, chksum_swapped);
#else /* TCP_CHECKSUM_ON_COPY*/
#define TCP_DATA_COPY(dst, src, len, seg)                     MEMCPY(dst, src, len)
#define TCP_DATA_COPY2(dst, src, len, chksum, chksum_swapped) MEMCPY(dst, src, len)
#endif /* TCP_CHECKSUM_ON_COPY*/

/** Define this to 1 for an extra check that the output checksum is valid
 * (usefule when the checksum is generated by the application, not the stack) */
#ifndef TCP_CHECKSUM_ON_COPY_SANITY_CHECK
#define TCP_CHECKSUM_ON_COPY_SANITY_CHECK   0
#endif
/* Allow to override the failure of sanity check from warning to e.g. hard failure */
#if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
#ifndef TCP_CHECKSUM_ON_COPY_SANITY_CHECK_FAIL
#define TCP_CHECKSUM_ON_COPY_SANITY_CHECK_FAIL(msg) LWIP_DEBUGF(TCP_DEBUG | LWIP_DBG_LEVEL_WARNING, msg)
#endif
#endif

#if TCP_OVERSIZE
/** The size of segment pbufs created when TCP_OVERSIZE is enabled */
#ifndef TCP_OVERSIZE_CALC_LENGTH
#define TCP_OVERSIZE_CALC_LENGTH(length) ((length) + TCP_OVERSIZE)
#endif
#endif

/* Forward declarations.*/
static err_t tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif);

/** Allocate a pbuf and create a tcphdr at p->payload, used for output
 * functions other than the default tcp_output -> tcp_output_segment
 * (e.g. tcp_send_empty_ack, etc.)
 *
 * @param pcb tcp pcb for which to send a packet (used to initialize tcp_hdr)
 * @param optlen length of header-options
 * @param datalen length of tcp data to reserve in pbuf
 * @param seqno_be seqno in network byte order (big-endian)
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
  if (p != NULL) {

#if LWIP_ENABLE_UNILOG
    if(p->len < TCP_HLEN + optlen) {
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_alloc_header_1, P_ERROR, 0, "check that first pbuf can hold struct tcp_hdr");
    }
#else
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
#endif
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = lwip_htons(pcb->local_port);
    tcphdr->dest = lwip_htons(pcb->remote_port);
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
    tcphdr->chksum = 0;
    tcphdr->urgp = 0;

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
  }
  return p;
}

/**
 * Called by tcp_close() to send a segment including FIN flag but not data.
 *
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
      pcb->flags |= TF_FIN;
      return ERR_OK;
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
}

/**
 * Create a TCP segment with prefilled header.
 *
 * Called by tcp_write and tcp_enqueue_flags.
 *
 * @param pcb Protocol control block for the TCP connection.
 * @param p pbuf that is used to hold the TCP header.
 * @param flags TCP flags for header.
 * @param seqno TCP sequence number of this packet
 * @param optflags options to include in TCP header
 * @return a new tcp_seg pointing to p, or NULL.
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
#if LWIP_ENABLE_UNILOG
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_create_segment_1, P_WARNING, 0, "tcp_create_segment: no memory");
#else
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no memory.\n"));
#endif
    pbuf_free(p);
    return NULL;
  }
#if ENABLE_PSIF
  memset(seg->sequence_state, 0, sizeof(seg->sequence_state));
#endif
  seg->flags = optflags;
  seg->next = NULL;
  seg->p = p;
#if LWIP_ENABLE_UNILOG
  if(p->tot_len < optlen) {
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_create_segment_2, P_ERROR, 0, "p->tot_len >= optlen");
  }
#else
  LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
#endif
  seg->len = p->tot_len - optlen;
#if TCP_OVERSIZE_DBGCHECK
  seg->oversize_left = 0;
#endif /* TCP_OVERSIZE_DBGCHECK */
#if TCP_CHECKSUM_ON_COPY
  seg->chksum = 0;
  seg->chksum_swapped = 0;
  /* check optflags */
#if LWIP_ENABLE_UNILOG
  if((optflags & TF_SEG_DATA_CHECKSUMMED) != 0) {
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_create_segment_3, P_ERROR, 0, "invalid optflags passed: TF_SEG_DATA_CHECKSUMMED");
  }
#else
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
#if LWIP_ENABLE_UNILOG
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_create_segment_4, P_WARNING, 0, "tcp_create_segment: no room for TCP header in pbuf");
#else
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
#endif
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = lwip_htons(pcb->local_port);
  seg->tcphdr->dest = lwip_htons(pcb->remote_port);
  seg->tcphdr->seqno = lwip_htonl(seqno);
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
  return seg;
}

/**
 * Allocate a PBUF_RAM pbuf, perhaps with extra space at the end.
 *
 * This function is like pbuf_alloc(layer, length, PBUF_RAM) except
 * there may be extra bytes available at the end.
 *
 * @param layer flag to define header size.
 * @param length size of the pbuf's payload.
 * @param max_length maximum usable size of payload+oversize.
 * @param oversize pointer to a u16_t that will receive the number of usable tail bytes.
 * @param pcb The TCP connection that will enqueue the pbuf.
 * @param apiflags API flags given to tcp_write.
 * @param first_seg true when this pbuf will be used in the first enqueued segment.
 */
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
  struct pbuf *p;
  u16_t alloc = length;

#if LWIP_NETIF_TX_SINGLE_PBUF
  LWIP_UNUSED_ARG(max_length);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
    /* Should we allocate an oversized pbuf, or just the minimum
     * length required? If tcp_write is going to be called again
     * before this segment is transmitted, we want the oversized
     * buffer. If the segment will be transmitted immediately, we can
     * save memory by allocating only length. We use a simple
     * heuristic based on the following information:
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
        (!(pcb->flags & TF_NODELAY) &&
         (!first_seg ||
          pcb->unsent != NULL ||
          pcb->unacked != NULL))) {
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(TCP_OVERSIZE_CALC_LENGTH(length)));
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
  if (p == NULL) {
    return NULL;
  }
#if LWIP_ENABLE_UNILOG
  if(p->next != NULL) {
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_pbuf_prealloc_1, P_ERROR, 0, "need unchained pbuf");
  }
#else
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
#endif
  *oversize = p->len - length;
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
  return p;
}
#else /* TCP_OVERSIZE */
#define tcp_pbuf_prealloc(layer, length, mx, os, pcb, api, fst) pbuf_alloc((layer), (length), PBUF_RAM)
#endif /* TCP_OVERSIZE */

#if TCP_CHECKSUM_ON_COPY
/** Add a checksum of newly added data to the segment */
static void
tcp_seg_add_chksum(u16_t chksum, u16_t len, u16_t *seg_chksum,
                   u8_t *seg_chksum_swapped)
{
  u32_t helper;
  /* add chksum to old chksum and fold to u16_t */
  helper = chksum + *seg_chksum;
  chksum = FOLD_U32T(helper);
  if ((len & 1) != 0) {
    *seg_chksum_swapped = 1 - *seg_chksum_swapped;
    chksum = SWAP_BYTES_IN_WORD(chksum);
  }
  *seg_chksum = chksum;
}
#endif /* TCP_CHECKSUM_ON_COPY */

/** Checks if tcp_write is allowed or not (checks state, snd_buf and snd_queuelen).
 *
 * @param pcb the tcp pcb to check for
 * @param len length of data to send (checked agains snd_buf)
 * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
      (pcb->state != SYN_RCVD)) {
#if LWIP_ENABLE_UNILOG
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_checks_1, P_WARNING, 0, "tcp_write() called in invalid state");
#else
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
#endif
    return ERR_CONN;
  } else if (len == 0) {
    return ERR_OK;
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
#if LWIP_ENABLE_UNILOG
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_checks_2, P_WARNING, 2, "tcp_write: too much data (len %u > snd_buf %u)", len, pcb->snd_buf);
#else
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"TCPWNDSIZE_F")\n",
      len, pcb->snd_buf));
#endif
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }

#if LWIP_ENABLE_UNILOG
  ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_checks_3, P_INFO, 1, "tcp_write: queuelen: %u", (tcpwnd_size_t)pcb->snd_queuelen);
#else
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));
#endif

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
#if LWIP_ENABLE_UNILOG
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_checks_4, P_INFO, 2, "tcp_write: too long queue %u (max %u)", pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN);
#else
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
      pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN));
#endif
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (pcb->snd_queuelen != 0) {
#if LWIP_ENABLE_UNILOG
    if(pcb->unacked == NULL && pcb->unsent == NULL) {
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_checks_5, P_ERROR, 0, "tcp_write: pbufs on queue => at least one queue non-empty");
    }
#else
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
      pcb->unacked != NULL || pcb->unsent != NULL);
#endif
  } else {
#if LWIP_ENABLE_UNILOG
    if(pcb->unacked != NULL || pcb->unsent != NULL) {
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_checks_6, P_ERROR, 0, "tcp_write: no pbufs on queue => both queues empty");
    }
#else
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
      pcb->unacked == NULL && pcb->unsent == NULL);
#endif
  }
  return ERR_OK;
}

/**
 * @ingroup tcp_raw
 * Write data for sending (but does not send it immediately).
 *
 * It waits in the expectation of more data being sent soon (as
 * it can send them more efficiently by combining them together).
 * To prompt the system to send data now, call tcp_output() after
 * calling tcp_write().
 *
 * @param pcb Protocol control block for the TCP connection to enqueue data for.
 * @param arg Pointer to the data to be enqueued for sending.
 * @param len Data length in bytes
 * @param apiflags combination of following flags :
 * - TCP_WRITE_FLAG_COPY (0x01) data will be copied into memory belonging to the stack
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will not be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
#if ENABLE_PSIF
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags, u8_t dataRai, u8_t exceptdata, u8_t sequence)
#else
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
#endif
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
  u16_t pos = 0; /* position in 'arg' data */
  u16_t queuelen;
  u8_t optlen = 0;
  u8_t optflags = 0;
#if TCP_OVERSIZE
  u16_t oversize = 0;
  u16_t oversize_used = 0;
#if TCP_OVERSIZE_DBGCHECK
  u16_t oversize_add = 0;
#endif /* TCP_OVERSIZE_DBGCHECK*/
#endif /* TCP_OVERSIZE */
  u16_t extendlen = 0;
#if TCP_CHECKSUM_ON_COPY
  u16_t concat_chksum = 0;
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max/2));
  mss_local = mss_local ? mss_local : pcb->mss;

#if LWIP_NETIF_TX_SINGLE_PBUF
  /* Always copy to try to create single pbufs for TX */
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

#if LWIP_ENABLE_UNILOG
  ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_1, P_INFO, 4, "tcp_write(pcb=0x%x, data=0x%x, len=%u, apiflags=%u)", (void *)pcb, arg, len, (u16_t)apiflags);
  if(arg == NULL) {
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_2, P_ERROR, 0, "tcp_write: arg == NULL (programmer violates API");
    return ERR_ARG;
  }
#else
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
             arg != NULL, return ERR_ARG;);
#endif

  err = tcp_write_checks(pcb, len);
  if (err != ERR_OK) {
    return err;
  }
  queuelen = pcb->snd_queuelen;

#if LWIP_TCP_TIMESTAMPS
  if ((pcb->flags & TF_TIMESTAMP)) {
    /* Make sure the timestamp option is only included in data segments if we
       agreed about it with the remote host. */
    optflags = TF_SEG_OPTS_TS;
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
    /* ensure that segments can hold at least one data byte... */
    mss_local = LWIP_MAX(mss_local, LWIP_TCP_OPT_LEN_TS + 1);
  }
#endif /* LWIP_TCP_TIMESTAMPS */


  /*
   * TCP segmentation is done in three phases with increasing complexity:
   *
   * 1. Copy data directly into an oversized pbuf.
   * 2. Chain a new pbuf to the end of pcb->unsent.
   * 3. Create new segments.
   *
   * We may run out of memory at any point. In that case we must
   * return ERR_MEM and not change anything in pcb. Therefore, all
   * changes are recorded in local variables and committed at the end
   * of the function. Some pcb fields are maintained in local copies:
   *
   * queuelen = pcb->snd_queuelen
   * oversize = pcb->unsent_oversize
   *
   * These variables are set consistently by the phases:
   *
   * seg points to the last segment tampered with.
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
#if LWIP_ENABLE_UNILOG
  if(mss_local < last_unsent->len + unsent_optlen) {
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_3, P_ERROR, 0, "mss_local is too small");
  }
#else
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
#endif
    space = mss_local - (last_unsent->len + unsent_optlen);

    /*
     * Phase 1: Copy data directly into an oversized pbuf.
     *
     * The number of bytes copied is recorded in the oversize_used
     * variable. The actual copying is done at the bottom of the
     * function.
     */
#if TCP_OVERSIZE
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->oversize_left */
#if LWIP_ENABLE_UNILOG
    if(pcb->unsent_oversize != last_unsent->oversize_left) {
      ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_4, P_ERROR, 0, "unsent_oversize mismatch (pcb vs. last_unsent)");
    }
#else
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
    if (oversize > 0) {
#if LWIP_ENABLE_UNILOG
      if(oversize > space) {
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_5, P_ERROR, 0, "inconsistent oversize vs. space");
      }
#else
      LWIP_ASSERT("inconsistent oversize vs. space", oversize <= space);
#endif
      seg = last_unsent;
      oversize_used = LWIP_MIN(space, LWIP_MIN(oversize, len));
      pos += oversize_used;
      oversize -= oversize_used;
      space -= oversize_used;

#if ENABLE_PSIF
      /*set the last tcp segment pbuf dataRai and exceptdata value
       *1. if the pbuf is the last tcp segment of the pcb, set the dataRai
       *2. if the pbuf is the last tcp segment of the pcb, set the dataRai as 0
      */
      seg->p->bExceptData = exceptdata;
      if(pos == len) {
         if(dataRai == DATA_RAI_NO_UL_DL_FOLLOWED || dataRai == DATA_RAI_ONLY_DL_FOLLOWED) {
            seg->p->dataRai = DATA_RAI_ONLY_DL_FOLLOWED;
         }else {
            seg->p->dataRai = DATA_RAI_NO_INFO;
         }
      }else {
         seg->p->dataRai = DATA_RAI_NO_INFO;
      }

         //update the tcp segment sequence state
         if(sequence > 0)
         {
            updateSequenceBitmap(seg->sequence_state, sequence, 1);
         }
#endif

    }
    /* now we are either finished or oversize is zero */
#if LWIP_ENABLE_UNILOG
    if((oversize != 0) && (pos != len)) {
      ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_6, P_ERROR, 0, "inconsistent oversize vs. len");
    }
#else
    LWIP_ASSERT("inconsistent oversize vs. len", (oversize == 0) || (pos == len));
#endif
#endif /* TCP_OVERSIZE */

    /*
     * Phase 2: Chain a new pbuf to the end of pcb->unsent.
     *
     * As an exception when NOT copying the data, if the given data buffer
     * directly follows the last unsent data buffer in memory, extend the last
     * ROM pbuf reference to the buffer, thus saving a ROM pbuf allocation.
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
      u16_t seglen = LWIP_MIN(space, len - pos);
      seg = last_unsent;

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
#if LWIP_ENABLE_UNILOG
          ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_7, P_INFO, 1, "tcp_write : could not allocate memory for pbuf copy size %u", seglen);

#else
          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                      ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
                       seglen));
#endif
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        oversize_add = oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (const u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
#if TCP_CHECKSUM_ON_COPY
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
        queuelen += pbuf_clen(concat_p);
      } else {
        /* Data is not copied */
        /* If the last unsent pbuf is of type PBUF_ROM, try to extend it. */
        struct pbuf *p;
        for (p = last_unsent->p; p->next != NULL; p = p->next);
        if (p->type == PBUF_ROM && (const u8_t *)p->payload + p->len == (const u8_t *)arg) {
#if LWIP_ENABLE_UNILOG
          if(pos != 0) {
            ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_8, P_ERROR, 0, "tcp_write: ROM pbufs cannot be oversized");
          }
#else
          LWIP_ASSERT("tcp_write: ROM pbufs cannot be oversized", pos == 0);
#endif
          extendlen = seglen;
        } else {
          if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
#if LWIP_ENABLE_UNILOG
            ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_9, P_WARNING, 0, "tcp_write: could not allocate memory for zero-copy pbuf");
#else
            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                        ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
#endif
            goto memerr;
          }
          /* reference the non-volatile payload data */
          ((struct pbuf_rom*)concat_p)->payload = (const u8_t*)arg + pos;
          queuelen += pbuf_clen(concat_p);
        }
#if TCP_CHECKSUM_ON_COPY
        /* calculate the checksum of nocopy-data */
        tcp_seg_add_chksum(~inet_chksum((const u8_t*)arg + pos, seglen), seglen,
          &concat_chksum, &concat_chksum_swapped);
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
      }

      pos += seglen;

#if ENABLE_PSIF
          /*set the last tcp segment pbuf dataRai and exceptdata value
          *1. if the pbuf is the last tcp segment of the pcb, set the dataRai
          *2. if the pbuf is the last tcp segment of the pcb, set the dataRai as 0
          */
          seg->p->bExceptData = exceptdata;
          if(pos == len) {
            if(dataRai == DATA_RAI_NO_UL_DL_FOLLOWED || dataRai == DATA_RAI_ONLY_DL_FOLLOWED) {
                seg->p->dataRai = DATA_RAI_ONLY_DL_FOLLOWED;
            }else {
                seg->p->dataRai = DATA_RAI_NO_INFO;
            }
          }else {
            seg->p->dataRai = DATA_RAI_NO_INFO;
          }

         //update the tcp segment sequence state
         if(sequence > 0)
         {
            updateSequenceBitmap(seg->sequence_state, sequence, 1);
         }
#endif

    }
  } else {
#if TCP_OVERSIZE
#if LWIP_ENABLE_UNILOG
    if(pcb->unsent_oversize != 0) {
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_10, P_ERROR, 0, "unsent_oversize mismatch (pcb->unsent is NULL)");
    }
#else
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
                pcb->unsent_oversize == 0);
#endif
#endif /* TCP_OVERSIZE */
  }

  /*
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
    struct pbuf *p;
    u16_t left = len - pos;
    u16_t max_len = mss_local - optlen;
    u16_t seglen = LWIP_MIN(left, max_len);
#if TCP_CHECKSUM_ON_COPY
    u16_t chksum = 0;
    u8_t chksum_swapped = 0;
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
#if LWIP_ENABLE_UNILOG
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_11, P_WARNING, 1, "tcp_write : could not allocate memory for pbuf copy size %u", seglen);
#else
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
#endif
        goto memerr;
      }
#if LWIP_ENABLE_UNILOG
      if(p->len < seglen) {
          ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_12, P_ERROR, 0, "tcp_write: check that first pbuf can hold the complete seglen");
      }
#else
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
                  (p->len >= seglen));
#endif
      TCP_DATA_COPY2((char *)p->payload + optlen, (const u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
    } else {
      /* Copy is not set: First allocate a pbuf for holding the data.
       * Since the referenced data is available at least until it is
       * sent out on the link (as it has to be ACKed by the remote
       * party) we can safely use PBUF_ROM instead of PBUF_REF here.
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
#if LWIP_ENABLE_UNILOG
      if( oversize != 0) {
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_13, P_ERROR, 0, "oversize == 0");
      }
#else
      LWIP_ASSERT("oversize == 0", oversize == 0);
#endif
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
#if LWIP_ENABLE_UNILOG
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_14, P_WARNING, 0, "tcp_write: could not allocate memory for zero-copy pbu");
#else
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
#endif
        goto memerr;
      }
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((const u8_t*)arg + pos, seglen);
      if (seglen & 1) {
        chksum_swapped = 1;
        chksum = SWAP_BYTES_IN_WORD(chksum);
      }
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      ((struct pbuf_rom*)p2)->payload = (const u8_t*)arg + pos;

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p2);
#if LWIP_ENABLE_UNILOG
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_15, P_WARNING, 0, "tcp_write: could not allocate memory for header pbuf");
#else
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memory for header pbuf\n"));
#endif
        goto memerr;
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
    }

    queuelen += pbuf_clen(p);

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
#if LWIP_ENABLE_UNILOG
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_16, P_WARNING, 2, "tcp_write: queue too long %u (%d)", queuelen, (int)TCP_SND_QUEUELEN);
#else
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: queue too long %"U16_F" (%d)\n",
        queuelen, (int)TCP_SND_QUEUELEN));
#endif
      pbuf_free(p);
      goto memerr;
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
      goto memerr;
    }
#if TCP_OVERSIZE_DBGCHECK
    seg->oversize_left = oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
#if TCP_CHECKSUM_ON_COPY
    seg->chksum = chksum;
    seg->chksum_swapped = chksum_swapped;
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
      queue = seg;
    } else {
      /* Attach the segment to the end of the queued segments */
#if LWIP_ENABLE_UNILOG
      if(prev_seg == NULL) {
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_17, P_ERROR, 0, "prev_seg != NULL");
      }
#else
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
#endif
      prev_seg->next = seg;
    }
    /* remember last segment of to-be-queued data for next iteration */
    prev_seg = seg;

#if LWIP_ENABLE_UNILOG
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_18, P_INFO, 2, "tcp_write: queueing %u:%u", lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg));
#else
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
      lwip_ntohl(seg->tcphdr->seqno),
      lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));
#endif

    pos += seglen;

#if ENABLE_PSIF
    /*set the last tcp segment pbuf esmRai and exceptdata value
     *1. if the new pbuf is the last tcp segment of the pcb, set the esmRai
     *2. if the new pbuf is the last tcp segment of the pcb, set the esmRai as 0
     */
     seg->p->bExceptData = exceptdata;
     if(pos == len) {
        if(dataRai == DATA_RAI_NO_UL_DL_FOLLOWED || dataRai == DATA_RAI_ONLY_DL_FOLLOWED) {
            seg->p->dataRai = DATA_RAI_ONLY_DL_FOLLOWED;
        }else {
            seg->p->dataRai = DATA_RAI_NO_INFO;
        }
     }else {
        seg->p->dataRai = DATA_RAI_NO_INFO;
     }

     //update the tcp segment sequence state
     if(sequence > 0)
     {
          updateSequenceBitmap(seg->sequence_state, sequence, 1);
     }
#endif

  }

  /*
   * All three segmentation phases were successful. We can commit the
   * transaction.
   */
#if TCP_OVERSIZE_DBGCHECK
  if ((last_unsent != NULL) && (oversize_add != 0)) {
    last_unsent->oversize_left += oversize_add;
  }
#endif /* TCP_OVERSIZE_DBGCHECK */

  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
      p->tot_len += oversize_used;
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
        p->len += oversize_used;
      }
    }
    last_unsent->len += oversize_used;
#if TCP_OVERSIZE_DBGCHECK
#if LWIP_ENABLE_UNILOG
    if(last_unsent->oversize_left < oversize_used) {
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_19, P_ERROR, 0, "last_unsent->oversize_left >= oversize_used");
    }
#else
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
#endif
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
#endif /* TCP_OVERSIZE */

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p, unless we
   * determined that the last ROM pbuf can be extended to include the new data.
   */
  if (concat_p != NULL) {
#if LWIP_ENABLE_UNILOG
    if(last_unsent == NULL) {
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_20, P_ERROR, 0, "tcp_write: cannot concatenate when pcb->unsent is empty");
    }
#else
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
      (last_unsent != NULL));
#endif
    pbuf_cat(last_unsent->p, concat_p);
    last_unsent->len += concat_p->tot_len;
  } else if (extendlen > 0) {
    struct pbuf *p;
#if LWIP_ENABLE_UNILOG
    if(last_unsent == NULL || last_unsent->p == NULL) {
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_21, P_ERROR, 0, "tcp_write: extension of reference requires reference");
    }
#else
    LWIP_ASSERT("tcp_write: extension of reference requires reference",
      last_unsent != NULL && last_unsent->p != NULL);
#endif
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
      p->tot_len += extendlen;
    }
    p->tot_len += extendlen;
    p->len += extendlen;
    last_unsent->len += extendlen;
  }

#if TCP_CHECKSUM_ON_COPY
  if (concat_chksummed) {
#if LWIP_ENABLE_UNILOG
    if(concat_p == NULL && extendlen <= 0) {
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_22, P_ERROR, 0, "tcp_write: concat checksum needs concatenated data");
    }
#else
    LWIP_ASSERT("tcp_write: concat checksum needs concatenated data",
        concat_p != NULL || extendlen > 0);
#endif
    /*if concat checksumm swapped - swap it back */
    if (concat_chksum_swapped) {
      concat_chksum = SWAP_BYTES_IN_WORD(concat_chksum);
    }
    tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
      &last_unsent->chksum_swapped);
    last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
  }
#endif /* TCP_CHECKSUM_ON_COPY */

  /*
   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
   * is harmless
   */
  if (last_unsent == NULL) {
    pcb->unsent = queue;
  } else {
    last_unsent->next = queue;
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
  pcb->snd_buf -= len;
  pcb->snd_queuelen = queuelen;

#if LWIP_ENABLE_UNILOG
  ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_23, P_INFO, 1, "tcp_write: %u (after enqueued)", pcb->snd_queuelen);
#else
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
    pcb->snd_queuelen));
#endif
  if (pcb->snd_queuelen != 0) {

#if LWIP_ENABLE_UNILOG
    if(pcb->unacked == NULL && pcb->unsent == NULL) {
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_24, P_ERROR, 0, "tcp_write: valid queue length");
    }
#else
    LWIP_ASSERT("tcp_write: valid queue length",
                pcb->unacked != NULL || pcb->unsent != NULL);
#endif
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  TCP_STATS_INC(tcp.memerr);

  if (concat_p != NULL) {
    pbuf_free(concat_p);
  }
  if (queue != NULL) {
#if ENABLE_PSIF
    //send the fail response for sequence state
    if(sequence > 0) {
        if(pcb->sockid < 0) {
            ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_27, P_ERROR, 1, "tcp_write: UL sequence state indicate fail, because the pcb 0x%x socket id is invalid", (void *)pcb);
        }else {
            u32_t bitmap[8];
            memset(bitmap, 0, sizeof(bitmap));
            updateSequenceBitmap(bitmap, sequence, 1);
            udp_send_ul_state_ind(bitmap, pcb->sockid, UL_SEQUENCE_STATE_DISCARD);
            ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_28, P_INFO, 1, "tcp_write: UL sequence state indicate success, the pcb socket id %u", pcb->sockid);
        }
    }
#endif
    tcp_segs_free(queue);
  }
  if (pcb->snd_queuelen != 0) {
#if LWIP_ENABLE_UNILOG
    if(pcb->unacked == NULL && pcb->unsent == NULL) {
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_25, P_ERROR, 0, "tcp_write: valid queue length2");
    }
#else
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
#endif
  }

#if LWIP_ENABLE_UNILOG
  ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_write_26, P_INFO, 1, "tcp_write: %u (with mem err)", pcb->snd_queuelen);
#else
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
#endif
  return ERR_MEM;
}

/**
 * Enqueue TCP options for transmission.
 *
 * Called by tcp_connect(), tcp_listen_input(), and tcp_send_ctrl().
 *
 * @param pcb Protocol control block for the TCP connection.
 * @param flags TCP header flags to set in the outgoing segment.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
  u8_t optlen = 0;

#if LWIP_ENABLE_UNILOG
  ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_enqueue_flags_1, P_INFO, 1, "tcp_enqueue_flags: queuelen: %u", (u16_t)pcb->snd_queuelen);
#else
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
#endif

#if LWIP_ENABLE_UNILOG
  if((flags & (TCP_SYN | TCP_FIN)) == 0) {
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_enqueue_flags_2, P_ERROR, 0, "tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)");
  }
#else
  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
              (flags & (TCP_SYN | TCP_FIN)) != 0);
#endif

  /* check for configured max queuelen and possible overflow (FIN flag should always come through!) */
  if (((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) &&
      ((flags & TCP_FIN) == 0)) {
#if LWIP_ENABLE_UNILOG
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_enqueue_flags_3, P_INFO, 2, "tcp_enqueue_flags: too long queue %u (max %u)", pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN);
#else
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
                                       pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN));
#endif
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }

  if (flags & TCP_SYN) {
    optflags = TF_SEG_OPTS_MSS;
#if LWIP_WND_SCALE
    if ((pcb->state != SYN_RCVD) || (pcb->flags & TF_WND_SCALE)) {
      /* In a <SYN,ACK> (sent in state SYN_RCVD), the window scale option may only
         be sent if we received a window scale option from the remote host. */
      optflags |= TF_SEG_OPTS_WND_SCALE;
    }
#endif /* LWIP_WND_SCALE */
  }
#if LWIP_TCP_TIMESTAMPS
  if ((pcb->flags & TF_TIMESTAMP)) {
    /* Make sure the timestamp option is only included in data segments if we
       agreed about it with the remote host. */
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    pcb->flags |= TF_NAGLEMEMERR;
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }

#if LWIP_ENABLE_UNILOG
  if(p->len < optlen) {
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_enqueue_flags_4, P_ERROR, 0, "tcp_enqueue_flags: check that first pbuf can hold optlen");
  }
#else
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));
#endif

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    pcb->flags |= TF_NAGLEMEMERR;
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }
#if LWIP_ENABLE_UNILOG
  if(((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) != 0 || seg->len != 0) {
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_enqueue_flags_5, P_ERROR, 0, "tcp_enqueue_flags: seg->tcphdr not aligned or invalid segment length");
  }
  ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_enqueue_flags_6, P_INFO, 3, "tcp_enqueue_flags: queueing %u:%u (0x%x)", lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg), (u16_t)flags);
#else
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE,
              ("tcp_enqueue_flags: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
               lwip_ntohl(seg->tcphdr->seqno),
               lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));
#endif

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
    pcb->unsent = seg;
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
    useg->next = seg;
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    pcb->snd_lbb++;
    /* optlen does not influence snd_buf */
  }
  if (flags & TCP_FIN) {
    pcb->flags |= TF_FIN;
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
#if LWIP_ENABLE_UNILOG
  ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_enqueue_flags_7, P_INFO, 1, "tcp_enqueue_flags: %u (after enqueued)", pcb->snd_queuelen);
#else
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
#endif
  if (pcb->snd_queuelen != 0) {
#if LWIP_ENABLE_UNILOG
  if(pcb->unacked == NULL && pcb->unsent == NULL) {
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_enqueue_flags_8, P_ERROR, 0, "tcp_enqueue_flags: invalid queue length");
  }
#else
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
      pcb->unacked != NULL || pcb->unsent != NULL);
#endif
  }

  return ERR_OK;
}

#if LWIP_TCP_TIMESTAMPS
/* Build a timestamp option (12 bytes long) at the specified options pointer)
 *
 * @param pcb tcp_pcb
 * @param opts option pointer where to store the timestamp option
 */
static void
tcp_build_timestamp_option(struct tcp_pcb *pcb, u32_t *opts)
{
  /* Pad with two NOP options to make everything nicely aligned */
  opts[0] = PP_HTONL(0x0101080A);
  opts[1] = lwip_htonl(sys_now());
  opts[2] = lwip_htonl(pcb->ts_recent);
}
#endif

#if LWIP_WND_SCALE
/** Build a window scale option (3 bytes long) at the specified options pointer)
 *
 * @param opts option pointer where to store the window scale option
 */
static void
tcp_build_wnd_scale_option(u32_t *opts)
{
  /* Pad with one NOP option to make everything nicely aligned */
  opts[0] = PP_HTONL(0x01030300 | TCP_RCV_SCALE);
}
#endif

/**
 * Send an ACK without data.
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
  err_t err;
  struct pbuf *p;
  u8_t optlen = 0;
  struct netif *netif;
#if LWIP_TCP_TIMESTAMPS || CHECKSUM_GEN_TCP
  struct tcp_hdr *tcphdr;
#endif /* LWIP_TCP_TIMESTAMPS || CHECKSUM_GEN_TCP */

#if LWIP_TCP_TIMESTAMPS
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt));
  if (p == NULL) {
    /* let tcp_fasttmr retry sending this ACK */
#if LWIP_TIMER_ON_DEMOND
    //active delay ack timer
  if(tcp_get_timer_active_state(pcb, LWIP_SYS_TIMER_TYPE_TCP_DELAY_ACK)) {
     ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_send_empty_ack_4, P_INFO, 1, "tcp delay ack timer has enable");
  }else{
     sys_timeout(TCP_DELAY_ACK_TIMER, lwip_sys_timeout_handler_list[LWIP_SYS_TIMER_TYPE_TCP_DELAY_ACK], (void *)pcb);
     tcp_enable_timer_active_mask(pcb, LWIP_SYS_TIMER_TYPE_TCP_DELAY_ACK);
     ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_send_empty_ack_3, P_INFO, 1, "enable tcp delay ack timer %u", TCP_DELAY_ACK_TIMER);
  }
#endif
    pcb->flags |= (TF_ACK_DELAY | TF_ACK_NOW);
#if LWIP_ENABLE_UNILOG
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_send_empty_ack_1, P_INFO, 0, "tcp_output: (ACK) could not allocate pbuf");
#else
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
#endif
    return ERR_BUF;
  }
#if LWIP_TCP_TIMESTAMPS || CHECKSUM_GEN_TCP
  tcphdr = (struct tcp_hdr *)p->payload;
#endif /* LWIP_TCP_TIMESTAMPS || CHECKSUM_GEN_TCP */

#if LWIP_ENABLE_UNILOG
  ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_send_empty_ack_2, P_INFO, 1, "tcp_output: sending ACK for %u", pcb->rcv_nxt);
#else
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG,
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
#endif

  /* NB. MSS and window scale options are only sent on SYNs, so ignore them here */
#if LWIP_TCP_TIMESTAMPS
  pcb->ts_lastacksent = pcb->rcv_nxt;

  if (pcb->flags & TF_TIMESTAMP) {
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif

  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
  if (netif == NULL) {
    err = ERR_RTE;
  }
#if LWIP_SUSPEND_UP_DATA_ENABLE
   else if(netif->is_suspend) {
    err = ERR_IF_SUSPEND;
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_send_empty_ack_8, P_SIG, 0, "send empty ack fail beacuse of netif suspend,it will retransmit depend on delay ack timer");
  }
#endif
  else {
#if CHECKSUM_GEN_TCP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
        &pcb->local_ip, &pcb->remote_ip);
    }
#endif
    NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
    err = ip_output_if(p, &pcb->local_ip, &pcb->remote_ip,
      pcb->ttl, pcb->tos, IP_PROTO_TCP, netif);
    NETIF_SET_HWADDRHINT(netif, NULL);
  }
  pbuf_free(p);

  if (err != ERR_OK) {
    /* let tcp_fasttmr retry sending this ACK */
#if LWIP_TIMER_ON_DEMOND
  //active delay ack timer
  if(tcp_get_timer_active_state(pcb, LWIP_SYS_TIMER_TYPE_TCP_DELAY_ACK)) {
     ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_send_empty_ack_5, P_INFO, 1, "tcp delay ack timer has enable");
  }else{
     sys_timeout(TCP_DELAY_ACK_TIMER, lwip_sys_timeout_handler_list[LWIP_SYS_TIMER_TYPE_TCP_DELAY_ACK], (void *)pcb);
     tcp_enable_timer_active_mask(pcb, LWIP_SYS_TIMER_TYPE_TCP_DELAY_ACK);
     ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_send_empty_ack_6, P_INFO, 1, "enable tcp delay ack timer %u", TCP_DELAY_ACK_TIMER);
  }
#endif
    pcb->flags |= (TF_ACK_DELAY | TF_ACK_NOW);
  } else {
    /* remove ACK flags from the PCB, as we sent an empty ACK now */
#if LWIP_TIMER_ON_DEMOND
   if(tcp_get_timer_active_state(pcb, LWIP_SYS_TIMER_TYPE_TCP_DELAY_ACK)) {
      sys_untimeout(lwip_sys_timeout_handler_list[LWIP_SYS_TIMER_TYPE_TCP_DELAY_ACK], (void *)pcb);
      tcp_disable_timer_active_mask(pcb, LWIP_SYS_TIMER_TYPE_TCP_DELAY_ACK);
      ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_send_empty_ack_7, P_INFO, 0, "remove tcp delay ack timer");
   }
#endif
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  }

  return err;
}

/**
 * @ingroup tcp_raw
 * Find out what we can send and send it
 *
 * @param pcb Protocol control block for the TCP connection to send data
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg, *useg;
  u32_t wnd, snd_nxt;
  err_t err;
  struct netif *netif;
#if TCP_CWND_DEBUG
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  /* pcb->state LISTEN not allowed here */
#if LWIP_ENABLE_UNILOG
  if(pcb->state == LISTEN) {
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_1, P_ERROR, 0, "don't call tcp_output for listen-pcbs");
  }
#else
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
    pcb->state != LISTEN);
#endif


  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);

  seg = pcb->unsent;

  /* If the TF_ACK_NOW flag is set and no data will be sent (either
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  if (useg != NULL) {
    for (; useg->next != NULL; useg = useg->next);
  }

  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
  if (netif == NULL) {
    return ERR_RTE;
  }

  /* If we don't have a local IP address, we get one from netif */
  if (ip_addr_isany(&pcb->local_ip)) {
    const ip_addr_t *local_ip = ip_netif_get_local_ip(netif, &pcb->remote_ip);
    if (local_ip == NULL) {
      return ERR_RTE;
    }
    ip_addr_copy(pcb->local_ip, *local_ip);
  }

#if TCP_OUTPUT_DEBUG
  if (seg == NULL) {
#if LWIP_ENABLE_UNILOG
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_2, P_INFO, 1, "tcp_output: nothing to send 0x%x", (void*)pcb->unsent);
#else
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: nothing to send (%p)\n",
                                   (void*)pcb->unsent));
#endif
  }
#endif /* TCP_OUTPUT_DEBUG */
#if TCP_CWND_DEBUG
  if (seg == NULL) {
#if LWIP_ENABLE_UNILOG
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_3, P_INFO, 4, "tcp_output: snd_wnd(%u) cwnd(%u) wnd(%u) seq == NULL, ack %u", pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack);
#else
    LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"TCPWNDSIZE_F
                                 ", cwnd %"TCPWNDSIZE_F", wnd %"U32_F
                                 ", seg == NULL, ack %"U32_F"\n",
                                 pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));
#endif
  } else {

#if LWIP_ENABLE_UNILOG
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_4, P_INFO, 6, "tcp_output: snd_wnd(%u) cwnd(%u) wnd(%u) effwnd(%u) seq (%u), ack %u", pcb->snd_wnd, pcb->cwnd, wnd, lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len, lwip_ntohl(seg->tcphdr->seqno), pcb->lastack);
#else
    LWIP_DEBUGF(TCP_CWND_DEBUG,
                ("tcp_output: snd_wnd %"TCPWNDSIZE_F", cwnd %"TCPWNDSIZE_F", wnd %"U32_F
                 ", effwnd %"U32_F", seq %"U32_F", ack %"U32_F"\n",
                 pcb->snd_wnd, pcb->cwnd, wnd,
                 lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 lwip_ntohl(seg->tcphdr->seqno), pcb->lastack));
#endif
  }
#endif /* TCP_CWND_DEBUG */
  /* Check if we need to start the persistent timer when the next unsent segment
   * does not fit within the remaining send window and RTO timer is not running (we
   * have no in-flight data). A traditional approach would fill the remaining window
   * with part of the unsent segment (which will engage zero-window probing upon
   * reception of the zero window update from the receiver). This ensures the
   * subsequent window update is reliably received. With the goal of being lightweight,
   * we avoid splitting the unsent segment and treat the window as already zero.
   */
  if (seg != NULL &&
      lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd &&
      wnd > 0 && wnd == pcb->snd_wnd && pcb->unacked == NULL) {
    /* Start the persist timer */
    if (pcb->persist_backoff == 0) {
      pcb->persist_cnt = 0;
      pcb->persist_backoff = 1;
    }
    goto output_done;
  }
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
#if LWIP_ENABLE_UNILOG
  if((TCPH_FLAGS(seg->tcphdr) & TCP_RST) != 0) {
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_5, P_ERROR, 0, "RST not expected here!");
  }
#else
    LWIP_ASSERT("RST not expected here!",
                (TCPH_FLAGS(seg->tcphdr) & TCP_RST) == 0);
#endif
    /* Stop sending if the nagle algorithm would prevent it
     * Don't stop:
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if ((tcp_do_output_nagle(pcb) == 0) &&
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
      break;
    }
#if TCP_CWND_DEBUG
#if LWIP_ENABLE_UNILOG
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_6, P_INFO, 7, "tcp_output: snd_wnd(%u) cwnd(%u) wnd(%u) effwnd(%u) seq (%u), ack %u i(%u)", pcb->snd_wnd, pcb->cwnd, wnd, lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len, lwip_ntohl(seg->tcphdr->seqno), pcb->lastack, i);
#else

    LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"TCPWNDSIZE_F", cwnd %"TCPWNDSIZE_F", wnd %"U32_F", effwnd %"U32_F", seq %"U32_F", ack %"U32_F", i %"S16_F"\n",
                            pcb->snd_wnd, pcb->cwnd, wnd,
                            lwip_ntohl(seg->tcphdr->seqno) + seg->len -
                            pcb->lastack,
                            lwip_ntohl(seg->tcphdr->seqno), pcb->lastack, i));
#endif
    ++i;
#endif /* TCP_CWND_DEBUG */

    if (pcb->state != SYN_SENT) {
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
    }

#if TCP_OVERSIZE_DBGCHECK
    seg->oversize_left = 0;
#endif /* TCP_OVERSIZE_DBGCHECK */
    err = tcp_output_segment(seg, pcb, netif);
    if (err == ERR_IF_SUSPEND || err == ERR_IF_OOS || err == ERR_IF_HIGH_WATER) {
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_8, P_SIG, 1, "tcp output fail because of UL FAIL cause %u, it will retry later when retry time timeout", err);
    }else if(err != ERR_OK) {
      /* segment could not be sent, for whatever reason */
      pcb->flags |= TF_NAGLEMEMERR;
      return err;
    }
    pcb->unsent = seg->next;
    if (pcb->state != SYN_SENT) {
#if LWIP_TIMER_ON_DEMOND
      //deactive delay ack timer
      if(tcp_get_timer_active_state(pcb, LWIP_SYS_TIMER_TYPE_TCP_DELAY_ACK)) {
        sys_untimeout(lwip_sys_timeout_handler_list[LWIP_SYS_TIMER_TYPE_TCP_DELAY_ACK], (void *)pcb);
        tcp_disable_timer_active_mask(pcb, LWIP_SYS_TIMER_TYPE_TCP_DELAY_ACK);
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_7, P_INFO, 0, "remove tcp delay ack timer");
      }
#endif
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
    snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
      pcb->snd_nxt = snd_nxt;
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
      seg->next = NULL;
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
        pcb->unacked = seg;
        useg = seg;
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
            TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
          }
          seg->next = (*cur_seg);
          (*cur_seg) = seg;
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }
output_done:
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}

/**
 * Called by tcp_output() to actually send a TCP segment over IP.
 *
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 * @param netif the netif used to send the segment
 */
static err_t
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif)
{
  err_t err;
  u16_t len;
  u32_t *opts;

  if (seg->p->ref != 1) {
    /* This can happen if the pbuf of this segment is still referenced by the
       netif driver due to deferred transmission. Since this function modifies
       p->len, we must not continue in this case. */
    return ERR_OK;
  }

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);

  /* advertise our receive window size in this TCP segment */
#if LWIP_WND_SCALE
  if (seg->flags & TF_SEG_OPTS_WND_SCALE) {
    /* The Window field in a SYN segment itself (the only type where we send
       the window scale option) is never scaled. */
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(pcb->rcv_ann_wnd));
  } else
#endif /* LWIP_WND_SCALE */
  {
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
  }

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  /* cast through void* to get rid of alignment warnings */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
  if (seg->flags & TF_SEG_OPTS_MSS) {
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->local_ip, &pcb->remote_ip);
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
    opts += 1;
  }
#if LWIP_TCP_TIMESTAMPS
  pcb->ts_lastacksent = pcb->rcv_nxt;

  if (seg->flags & TF_SEG_OPTS_TS) {
    tcp_build_timestamp_option(pcb, opts);
    opts += 3;
  }
#endif
#if LWIP_WND_SCALE
  if (seg->flags & TF_SEG_OPTS_WND_SCALE) {
    tcp_build_wnd_scale_option(opts);
    opts += 1;
  }
#endif

  /* Set retransmission timer running if it is not currently enabled
     This must be set before checking the route. */

#if LWIP_TIMER_ON_DEMOND
  if(!tcp_get_timer_active_state(pcb, LWIP_SYS_TIMER_TYPE_TCP_RETRY)) {
      sys_timeout(pcb->rto * TCP_SLOW_INTERVAL, lwip_sys_timeout_handler_list[LWIP_SYS_TIMER_TYPE_TCP_RETRY], (void *)pcb);
      tcp_enable_timer_active_mask(pcb, LWIP_SYS_TIMER_TYPE_TCP_RETRY);
      ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_segment_5, P_INFO, 2, "enable tcp retry timer %u, pcb 0x%x", pcb->rto * TCP_SLOW_INTERVAL, (void *)pcb);
      if (pcb->rtime < 0) {
        pcb->rtime = 0;
      }
  }else {
      ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_segment_6, P_WARNING, 0, " tcp retry timer has active");
  }

    if(pcb->state != SYN_SENT) {
        if(!tcp_get_timer_active_state(pcb, LWIP_SYS_TIMER_TYPE_TCP_TOTAL_RETRY_TIMEOUT)) {
            sys_timeout(pcb->tcp_max_total_retry_time * 1000, lwip_sys_timeout_handler_list[LWIP_SYS_TIMER_TYPE_TCP_TOTAL_RETRY_TIMEOUT], (void *)pcb);
            tcp_enable_timer_active_mask(pcb, LWIP_SYS_TIMER_TYPE_TCP_TOTAL_RETRY_TIMEOUT);
            ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_segment_tcp_total_retry_time_1, P_INFO, 1, "enable tcp total retry timer %u", pcb->tcp_max_total_retry_time * 1000);
        }else {
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_segment_tcp_total_retry_time_2, P_WARNING, 0, " tcp total retry timer has active");
        }
    }

  /*
  *1. the TCP retry timer has active,there are some TCP data not ack yet,and maybe the data resent with the previous TCP segment
  *2. the TCP retry time is not active, the segement will be resent if the retry timer timeout
  */
  seg->p->tickType = UL_PDU_DISCARD_TICK;
  seg->p->sysTick = pcb->rto * TCP_SLOW_INTERVAL + sys_now();

  ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_segment_8, P_INFO, 2, " tcp output segment pbuf data ticktype %u, dataLifetime %u",seg->p->tickType, seg->p->sysTick);

#else
  if (pcb->rtime < 0) {
    pcb->rtime = 0;
  }
#endif


  if (pcb->rttest == 0) {
    if (pcb->state != SYN_SENT) {
#if LWIP_TIMER_ON_DEMOND
        pcb->rttest = sys_now();
#else
        pcb->rttest = tcp_ticks;
#endif

        pcb->rtseq = lwip_ntohl(seg->tcphdr->seqno);
#if LWIP_ENABLE_UNILOG
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_segment_1, P_INFO, 2, "tcp_output_segment: rtseq %u, rttest %u", pcb->rtseq, pcb->rttest);
#else
        LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_output_segment: rtseq %"U32_F"\n", pcb->rtseq));
#endif
     } else{
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_segment_10, P_INFO, 0, "tcp_output_segment: pcb in SYS_SENT state, discard rttest");
     }
  }

#if LWIP_ENABLE_UNILOG
  ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_segment_2, P_INFO, 2, "tcp_output_segment: %u:%u", lwip_htonl(seg->tcphdr->seqno), lwip_htonl(seg->tcphdr->seqno) + seg->len);
#else
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          lwip_htonl(seg->tcphdr->seqno), lwip_htonl(seg->tcphdr->seqno) +
          seg->len));
#endif

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  if (len == 0) {
    /** Exclude retransmitted segments from this count. */
    MIB2_STATS_INC(mib2.tcpoutsegs);
  }

  seg->p->len -= len;
  seg->p->tot_len -= len;

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
#if TCP_CHECKSUM_ON_COPY
    u32_t acc;
#if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
    u16_t chksum_slow = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
      seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
    if ((seg->flags & TF_SEG_DATA_CHECKSUMMED) == 0) {

#if LWIP_ENABLE_UNILOG
      if(seg->p->tot_len != (TCPH_HDRLEN(seg->tcphdr) * 4)) {
        ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_segment_3, P_ERROR, 0, "data included but not checksummed");
      }
#else
      LWIP_ASSERT("data included but not checksummed",
        seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
#endif
    }

    /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
      seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4, &pcb->local_ip, &pcb->remote_ip);
    /* add payload checksum */
    if (seg->chksum_swapped) {
      seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
      seg->chksum_swapped = 0;
    }
    acc += (u16_t)~(seg->chksum);
    seg->tcphdr->chksum = FOLD_U32T(acc);
#if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
    if (chksum_slow != seg->tcphdr->chksum) {
#if LWIP_ENABLE_UNILOG
      ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_segment_4, P_WARNING, 2, "tcp_output_segment: calculated checksum is %u instead of %u", seg->tcphdr->chksum, chksum_slow);
#else
      TCP_CHECKSUM_ON_COPY_SANITY_CHECK_FAIL(
                  ("tcp_output_segment: calculated checksum is %"X16_F" instead of %"X16_F"\n",
                  seg->tcphdr->chksum, chksum_slow));
#endif
      seg->tcphdr->chksum = chksum_slow;
    }
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
#else /* TCP_CHECKSUM_ON_COPY */
    seg->tcphdr->chksum = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
      seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
#endif /* TCP_CHECKSUM_ON_COPY */
  }
#endif /* CHECKSUM_GEN_TCP */

//if netif suspend, cancel sending. it will retry after the netif resume
#if LWIP_SUSPEND_UP_DATA_ENABLE
  if(netif->is_suspend) {
#if LWIP_ENABLE_UNILOG
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_output_segment_7, P_WARNING, 2, "tcp_output_segment: the netif is suspend netif %c%u",netif->name[0],netif->name[1]);
#endif
    return ERR_IF_SUSPEND;
  }
#endif

  TCP_STATS_INC(tcp.xmit);

  NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
  err = ip_output_if(seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
    pcb->tos, IP_PROTO_TCP, netif);
  NETIF_SET_HWADDRHINT(netif, NULL);
  return err;
}

/**
 * Send a TCP RESET packet (empty segment with RST flag set) either to
 * abort a connection or to show that there is no matching local connection
 * for a received segment.
 *
 * Called by tcp_abort() (to abort a local connection), tcp_input() (if no
 * matching local pcb was found), tcp_listen_input() (if incoming segment
 * has ACK flag set) and tcp_process() (received segment in the wrong state)
 *
 * Since a RST segment is in most cases not sent for an active connection,
 * tcp_rst() has a number of arguments that are taken from a tcp_pcb for
 * most other segment output functions.
 *
 * @param seqno the sequence number to use for the outgoing segment
 * @param ackno the acknowledge number to use for the outgoing segment
 * @param local_ip the local IP address to send the segment from
 * @param remote_ip the remote IP address to send the segment to
 * @param local_port the local TCP port to send the segment from
 * @param remote_port the remote TCP port to send the segment to
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  struct netif *netif;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  if (p == NULL) {
#if LWIP_ENABLE_UNILOG
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_rst_1, P_INFO, 0, "tcp_rst: could not allocate memory for pbuf");
#else
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
#endif
    return;
  }

#if LWIP_ENABLE_UNILOG
  if(p->len < sizeof(struct tcp_hdr)) {
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_rst_2, P_ERROR, 0, "check that first pbuf can hold struct tcp_hdr");
  }
#else
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));
#endif

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = lwip_htons(local_port);
  tcphdr->dest = lwip_htons(remote_port);
  tcphdr->seqno = lwip_htonl(seqno);
  tcphdr->ackno = lwip_htonl(ackno);
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
#if LWIP_WND_SCALE
  tcphdr->wnd = PP_HTONS(((TCP_WND >> TCP_RCV_SCALE) & 0xFFFF));
#else
  tcphdr->wnd = PP_HTONS(TCP_WND);
#endif
  tcphdr->chksum = 0;
  tcphdr->urgp = 0;

  TCP_STATS_INC(tcp.xmit);
  MIB2_STATS_INC(mib2.tcpoutrsts);

  netif = ip_route(local_ip, remote_ip);
  if (netif != NULL) {
#if CHECKSUM_GEN_TCP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
                                        local_ip, remote_ip);
    }
#endif
    /* Send output with hardcoded TTL/HL since we have no access to the pcb */
    ip_output_if(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP, netif);
  }
//there are not any retry timer for this rst pkg,so we do not check netif pending status.PS stack will pending this pkg

  pbuf_free(p);
#if LWIP_ENABLE_UNILOG
  ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_rst_3, P_INFO, 2, "tcp_rst: seqno %u ackno %u", seqno, ackno);
#else
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
#endif
}

/**
 * Requeue all unacked segments for retransmission
 *
 * Called by tcp_slowtmr() for slow retransmission.
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
#if TCP_OVERSIZE_DBGCHECK
  /* if last unsent changed, we need to update unsent_oversize */
  if (pcb->unsent == NULL) {
    pcb->unsent_oversize = seg->oversize_left;
  }
#endif /* TCP_OVERSIZE_DBGCHECK */
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  /* unacked queue is now empty */
  pcb->unacked = NULL;

  /* increment number of retransmissions */
  if (pcb->nrtx < 0xFF) {
    ++pcb->nrtx;
  }

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
}

/**
 * Requeue the first unacked segment for retransmission
 *
 * Called by tcp_receive() for fast retransmit.
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
    TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
  *cur_seg = seg;
#if TCP_OVERSIZE
  if (seg->next == NULL) {
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  if (pcb->nrtx < 0xFF) {
    ++pcb->nrtx;
  }

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission. */
  MIB2_STATS_INC(mib2.tcpretranssegs);
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
}


/**
 * Handle retransmission after three dupacks received
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
    /* This is fast retransmit. Retransmit the first unacked segment. */

#if LWIP_ENABLE_UNILOG
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_rexmit_fast_1, P_INFO, 3, "tcp_receive: dupacks %u(%u) fast retransmit %u", (u16_t)pcb->dupacks, pcb->lastack, lwip_ntohl(pcb->unacked->tcphdr->seqno));
#else
    LWIP_DEBUGF(TCP_FR_DEBUG,
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 lwip_ntohl(pcb->unacked->tcphdr->seqno)));
#endif
    tcp_rexmit(pcb);

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;

    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < (2U * pcb->mss)) {
#if LWIP_ENABLE_UNILOG
      ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_rexmit_fast_2, P_INFO, 2, "tcp_receive: The minimum value for ssthresh %u should be min 2 mss %u", pcb->ssthresh, (u16_t)(2*pcb->mss));
#else
      LWIP_DEBUGF(TCP_FR_DEBUG,
                  ("tcp_receive: The minimum value for ssthresh %"TCPWNDSIZE_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, (u16_t)(2*pcb->mss)));
#endif
      pcb->ssthresh = 2*pcb->mss;
    }

    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
    pcb->flags |= TF_INFR;

    /* Reset the retransmission timer to prevent immediate rto retransmissions */
#if LWIP_TIMER_ON_DEMOND
    if(tcp_get_timer_active_state(pcb, LWIP_SYS_TIMER_TYPE_TCP_RETRY)) {
      sys_untimeout(lwip_sys_timeout_handler_list[LWIP_SYS_TIMER_TYPE_TCP_RETRY], (void *)pcb);
      ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_rexmit_fast_3, P_INFO, 1, "remove tcp retry timer, pcb 0x%x", (void *)pcb);
    }
    sys_timeout(pcb->rto * TCP_SLOW_INTERVAL, lwip_sys_timeout_handler_list[LWIP_SYS_TIMER_TYPE_TCP_RETRY], (void *)pcb);
    tcp_enable_timer_active_mask(pcb, LWIP_SYS_TIMER_TYPE_TCP_RETRY);
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_rexmit_fast_4, P_INFO, 1, "enable tcp retry timer %u, pcb 0x%x", pcb->rto * TCP_SLOW_INTERVAL, (void *)pcb);
#endif
    pcb->rtime = 0;
  }
}


/**
 * Send keepalive packets to keep a connection active although
 * no data is sent over it.
 *
 * Called by tcp_slowtmr()
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
err_t
tcp_keepalive(struct tcp_pcb *pcb)
{
  err_t err;
  struct pbuf *p;
  struct netif *netif;

#if LWIP_ENABLE_UNILOG
  ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_keepalive_1, P_INFO, 0, "tcp_keepalive: sending KEEPALIVE probe to ");
#else
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: sending KEEPALIVE probe to "));
#endif
  ip_addr_debug_print(TCP_DEBUG, &pcb->remote_ip);
#ifndef LWIP_ENABLE_UNILOG
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));
#endif

#if LWIP_ENABLE_UNILOG
  ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_keepalive_2, P_INFO, 3, "tcp_keepalive: tcp_ticks %u pcb->tmr %u pcb->keep_cnt_sent %u", tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent);
#else
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
                          tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));
#endif

  p = tcp_output_alloc_header(pcb, 0, 0, lwip_htonl(pcb->snd_nxt - 1));
  if (p == NULL) {
#if LWIP_ENABLE_UNILOG
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_keepalive_3, P_WARNING, 0, "tcp_keepalive: could not allocate memory for pbuf");
#else
    LWIP_DEBUGF(TCP_DEBUG,
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
#endif
    return ERR_MEM;
  }
  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
  if (netif == NULL) {
    err = ERR_RTE;
  }
#if LWIP_SUSPEND_UP_DATA_ENABLE
   else if(netif->is_suspend) {
    err = ERR_IF_SUSPEND;
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_keepalive_4, P_SIG, 0, "send keepalive fail beacuse of netif suspend,it will retransmit depend on delay ack timer");
  }
#endif
  else {
#if CHECKSUM_GEN_TCP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
      struct tcp_hdr *tcphdr = (struct tcp_hdr *)p->payload;
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
        &pcb->local_ip, &pcb->remote_ip);
    }
#endif /* CHECKSUM_GEN_TCP */

#if ENABLE_PSIF
    p->tickType = UL_PDU_DISCARD_TICK;
#if LWIP_TCP_KEEPALIVE
    p->sysTick = pcb->keep_intvl + sys_now();
#else
    p->sysTick = TCP_KEEPINTVL_DEFAULT + sys_now();
#endif
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_keepalive_5, P_INFO, 2, "tcp_keepalive: pbuf tick type %u, dataLifeTime %u", p->tickType, p->sysTick);
#endif

    TCP_STATS_INC(tcp.xmit);

    /* Send output to IP */
    NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
    err = ip_output_if(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP, netif);
    NETIF_SET_HWADDRHINT(netif, NULL);
  }
  pbuf_free(p);

#if LWIP_ENABLE_UNILOG
  ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_keepalive_6, P_INFO, 3, "tcp_keepalive: seqno %u ackno %u err %d", pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err);
#else
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
#endif
  return err;
}


/**
 * Send persist timer zero-window probes to keep a connection active
 * when a window update is lost.
 *
 * Called by tcp_slowtmr()
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
err_t
tcp_zero_window_probe(struct tcp_pcb *pcb, u32_t retry_time)
{
  err_t err;
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  struct tcp_seg *seg;
  u16_t len;
  u8_t is_fin;
  u32_t snd_nxt;
  struct netif *netif;

#if LWIP_ENABLE_UNILOG
      ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_zero_window_probe_1, P_INFO, 0, "tcp_zero_window_probe: sending ZERO WINDOW probe to");
#else
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: sending ZERO WINDOW probe to "));
#endif
  ip_addr_debug_print(TCP_DEBUG, &pcb->remote_ip);
#ifndef LWIP_ENABLE_UNILOG
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));
#endif

#if LWIP_ENABLE_UNILOG
  ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_zero_window_probe_2, P_INFO, 3, "tcp_zero_window_probe: tcp_ticks %u pcb->tmr %u pcb->keep_cnt_sent %u", tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent);
#else
  LWIP_DEBUGF(TCP_DEBUG,
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
               tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));
#endif

  seg = pcb->unacked;

  if (seg == NULL) {
    seg = pcb->unsent;
  }
  if (seg == NULL) {
    /* nothing to send, zero window probe not needed */
    return ERR_OK;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
  if (p == NULL) {
#if LWIP_ENABLE_UNILOG
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_zero_window_probe_3, P_WARNING, 0, "tcp_zero_window_probe: no memory for pbuf");
#else
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
#endif
    return ERR_MEM;
  }
  tcphdr = (struct tcp_hdr *)p->payload;

  if (is_fin) {
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
  }

  /* The byte may be acknowledged without the window being opened. */
  snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
  if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
    pcb->snd_nxt = snd_nxt;
  }

  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
  if (netif == NULL) {
    err = ERR_RTE;
  }
#if LWIP_SUSPEND_UP_DATA_ENABLE
   else if(netif->is_suspend) {
    err = ERR_IF_SUSPEND;
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_zero_window_probe_5, P_SIG, 0, "send zero window probe pkg fail beacuse of netif suspend,it will retransmit depend on delay ack timer");
  }
#endif
  else {
#if CHECKSUM_GEN_TCP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
        &pcb->local_ip, &pcb->remote_ip);
    }
#endif

#if ENABLE_PSIF
    p->tickType = UL_PDU_DISCARD_TICK;
    p->sysTick = retry_time + sys_now();
    ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_zero_window_probe_6, P_INFO, 2, "tcp_zero_window_probe: pbuf ticktype %u,datalifetime %u", p->tickType, p->sysTick);
#endif
    TCP_STATS_INC(tcp.xmit);

    /* Send output to IP */
    NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
    err = ip_output_if(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
      0, IP_PROTO_TCP, netif);
    NETIF_SET_HWADDRHINT(netif, NULL);
  }

  pbuf_free(p);

#if LWIP_ENABLE_UNILOG
  ECOMM_TRACE(UNILOG_TCPIP_LWIP, tcp_zero_window_probe_7, P_INFO, 3, "tcp_zero_window_probe: seqno %u ackno %u err %d", pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err);
#else
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
#endif
  return err;
}
#endif /* LWIP_TCP */
